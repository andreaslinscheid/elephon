/*	This file ForceConstantMatrix.h is part of elephon.
 *
 *  elephon is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  elephon is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with elephon.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Created on: May 31, 2017
 *      Author: A. Linscheid
 */

#ifndef ELEPHON_PHONONSTRUCTURE_FORCECONSTANTMATRIX_H_
#define ELEPHON_PHONONSTRUCTURE_FORCECONSTANTMATRIX_H_

#include "Auxillary/AlignedVector.h"
#include <vector>
#include <complex>
#include <map>
#include <memory>

namespace elephon
{

namespace LatticeStructure { class PrimitiveToSupercellConnection; };
namespace LatticeStructure { class AtomDisplacementCollection; };
namespace LatticeStructure { class AtomDisplacement; };
namespace LatticeStructure { class Atom; };
namespace LatticeStructure { class UnitCell; };
namespace LatticeStructure { class Symmetry; };

namespace PhononStructure
{
class Forces;

/**
 *	Collection of methods and storage for the matrix of force constants.
 *
 */
class ForceConstantMatrix
{
public:

	/**
	 * Build the matrix of force constants from finite displacement data.
	 *
	 * Forces F(i,xi) acting on atom i in direction xi are given by
	 * 	F(i,xi) = \Phi(i,j,xi,xj) * u(j,xi)
	 * where \Phi is the matrix of force constants and u are the displacements of an atom j in direction xj.
	 * 	Here we solve for given (input) F and u for Phi.
	 *
	 * The general approach is the following (compare https://doi.org/10.1103/PhysRevLett.78.4063)
	 * 	1. find symmetry non-equivalent atoms
	 * 	2. For each atomic site, construct all reducible displacements that are generated by the
	 * 		irreducible displacement (where the forces have been calculated for) and the site-symmetry at this atomic position
	 * 	3. Solve the resolution system [u(j,xi)]*[F(i,xi)] (the brackets indicate the set of all reducible displacements)
	 * 		using the pseudo inverse which amounts to the least squares.
	 * 	4. Use the symmetry of the Matrix of force constants to expand the solutions to the symmetry equivalent atomic positions
	 *
	 * @todo This is a monolithic and quite complicated function. Furthermore it shares code with DisplacementPotential.
	 * 		  It is working but has to be the first target of refactoring one the electron-phonon coupling is completely working...
	 *
	 * @param primitiveCell		The physical primitive unit cell.
	 * @param superCell		The supercell. Currently the supercell must be a multiple of Nx, Ny and Nz
	 * 						of the primitive cell. No more complicated relation is allowed. The symmetry must be the same.
	 * @param irredDispl	A pointer to the list of irreducible displacements where the forces where obtained from.
	 * @param forces		For each irreducible displacement, a vector of forces on each atom as obtained by the
	 * 						electronic structure backend.
	 */
	void initialize( std::shared_ptr<const LatticeStructure::UnitCell> primitiveCell,
			std::shared_ptr<const LatticeStructure::UnitCell> superCell,
			std::shared_ptr<const LatticeStructure::AtomDisplacementCollection> irredDispl,
			std::shared_ptr<const LatticeStructure::PrimitiveToSupercellConnection> primToSupercell,
			std::shared_ptr<const PhononStructure::Forces> forces);

	double operator() (int Rz, int Ry, int Rx,int mu2, int mu1) const;

	void fourier_transform_q(std::vector<double> const & qVect,
			Auxillary::Multi_array<std::complex<double>,3> & dataFT,
			bool symmetrize = false) const;

	void fourier_transform_derivative(std::vector<double> const & qVect,
			Auxillary::alignedvector::ZV & data) const;

	int get_num_modes() const;

	int get_num_R() const;

	void symmetrize(
			bool accusticSumRule,
			LatticeStructure::Symmetry const & symmetry );

	void symmetrize_q(
			std::vector<double> const & qpoints,
			Auxillary::Multi_array<std::complex<double>,3> & dataFT,
			std::shared_ptr<const LatticeStructure::UnitCell> unitCell = nullptr) const;
private:

	int numModes_ = 0;

	Auxillary::Multi_array<int,3> indexLatticVectorMap_;

	Auxillary::Multi_array<double,3> data_;

	std::shared_ptr<const LatticeStructure::UnitCell> primitiveCell_;

	///For all atoms 'a' in the unit cell, tau_ contains for all atoms 'b' in the unit cell
	/// and the set of R vectors, indexed by iR, [a][b][iR] a set with vectors of atom positions
	Auxillary::Multi_array< Auxillary::Multi_array<double,2>, 3 > tau_;

	/// Same as tau_ but in cartesian coordinates in units of Angstroem
	Auxillary::Multi_array< Auxillary::Multi_array<double,2>, 3 > tauCart_;

	/// If from the perspective of an atom index 'ia' in the primitive cell, the atom 'ib'
	/// plus the lattice vector indexed by 'iR' is on the border of the supercell, we have to
	/// place a copy on the respective opposite border which is not in the supercell to maintain
	/// the local symmetry. This multipliticy is stored here. Layout is [ia][ib][iR]
	Auxillary::Multi_array<int,3> multiplicity_;

	void determine_lattice_vector(LatticeStructure::AtomDisplacement const & displ,
			std::vector<LatticeStructure::Atom> const & superCell,
			std::vector<int> & R, int & mu);

	void drift_clean_forces(
			std::vector<std::vector<double>> forces) const;

	void set_tau_vectors_and_multiplicity(std::shared_ptr<const LatticeStructure::UnitCell> primitiveCell,
			std::shared_ptr<const LatticeStructure::UnitCell> superCell,
			std::shared_ptr<const LatticeStructure::PrimitiveToSupercellConnection> primToSupercell );
};

} /* namespace PhononStructure */
} /* namespace elephon */

#endif /* ELEPHON_PHONONSTRUCTURE_FORCECONSTANTMATRIX_H_ */
