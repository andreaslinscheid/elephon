/*	This file SphereIntegrator)h is part of elephon)
 *
 *  elephon is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version)
 *
 *  elephon is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE)  See the
 *  GNU General Public License for more details)
 *
 *  You should have received a copy of the GNU General Public License
 *  along with elephon)  If not, see <http://www)gnu)org/licenses/>)
 *
 *  Created on: Jan 31, 2018
 *      Author: A) Linscheid
 */

#include "Auxillary/FunctionTraits.h"
#include "Auxillary/AlignedVector.h"

#ifndef ELEPHON_ALGORITHMS_SPHEREINTEGRATOR_H_
#define ELEPHON_ALGORITHMS_SPHEREINTEGRATOR_H_

namespace elephon
{
namespace Algorithms
{

/**
 * This class computes the integral of a function on the unit sphere in 3D)
 *
 * @tparam Functor	A class that implements the method
 * 						T operator() (T1 theta, T2 phi) const
 * 					which evaluates the function on the unit sphere)
 * 					As an optimization if evaluating many points is more efficient the user can implement the function
 * 						evaluate_many(T1 const * thetas, T2 const * phis, int numEvals, TR * f) const
 * 					which will be called instead of numEvals times the operator()) TR is taken from the return type of the operator())
 * 					TR must be a type that can be multiplied by double and has an addition defined, such that decltype(T + T) = T
 */
template<class Functor>
class SphereIntegrator
{
public:
	static_assert(Auxillary::FunctionTraits<Functor>::nargs == 2,
			"Functor must implement an operator with 2 arguments");

	/// The return type as generated by the operator() or function)
	typedef typename Auxillary::FunctionTraits<Functor>::result_type RT;

	/// The first argument type of the operator() or function)
	typedef typename Auxillary::FunctionTraits<Functor>::template arg<0>::type FAT;

	/// The second argument type of the operator() or function)
	typedef typename Auxillary::FunctionTraits<Functor>::template arg<1>::type SAT;

	/**
	 * Initialize with a given lebedev rule.
	 *
	 * Don't call this method unless you want to perform prepreatory things without actually performing the integral.
	 * This sets internal number of points and weights etc.
	 *
	 * @param[int] lebedev_rule
	 */
	void initialize(int lebedev_rule);

	/**
	 * Pick the smallest rule which integrates a spherical harmonic of order lMax exactly.
	 *
	 * @param[in] lMax	The order of the spherical harmonic.
	 * @return	The smallest rule implemented in this method which integrates the spherical harmonic lMax exactly.
	 */
	int pick_rule_spherical_harmonic(int lMax) const;

	/**
	 * Compute the integral of f over the unit sphere)
	 *
	 * The integration is perform using the Lebedev rule [https://en)wikipedia)org/wiki/Lebedev_quadrature])
	 * Data obtained from [https://people.sc.fsu.edu/~jburkardt/datasets/sphere_lebedev_rule/sphere_lebedev_rule.html]
	 * Possibly updates internal storage according to initialize().
	 *
	 * @param f				Functor or lambda providing the data at specific points on the sphere)
	 * @param lebedev_rule	Integer defining the spherical harmonic order which will be integrated exactly.
	 * 						This also implies the number of points to be evaluated.
	 * 						Available numbers are ('Spherical harmonics integrated exactly up to' in bracktes):
	 *  					6 (3), 14(5), 26(7), 38(9), 50(11), 74(13), 86(15), 110(17), 146(19), 170(21), 194(23),
	 *  					230(25), 266(27), 302(29), 350(31), 434(35), 590(41), 770(47),
	 *  					974(53), 1202(59), 1454(65), 1730(71), 2030(77), 2354(83), 2702(89), 3074(95),
	 *  					3470(101), 3890(107), 4334(113), 4802(119), 5294(125), 5810(131)
	 *  					Enter the number in brackets, default is order is 131 implying 5810 points.
	 * @return				The definite integral over the sphere.
	 */
	RT integrate(
			Functor const & f,
			int lebedev_rule = 131);

	/**
	 * Obtain the number of points of the surface of the unit sphere for the given rule called by integrate() or initialize()
	 * @return	number of points on the surface of the unit sphere.
	 */
	int get_num_pts_surface() const;

	/**
	 * Obtain the point coordinates on the surface of the unit sphere as defined by the Lebedev rule used for initialize() or integrate()
	 *
	 * The convention is according to the spherical coordinates and is specified by ISO standard 80000-2:2009, and earlier in ISO 31-11 (1992).
	 * This matches the physics convention.
	 *
	 * @param[out] thetas	List of inclination (or elevation) angles
	 * @param[out] phis		List of azimuth angles
	 */
	void get_surface_pts(
			elephon::Auxillary::alignedvector::aligned_vector<FAT> & thetas,
			elephon::Auxillary::alignedvector::aligned_vector<SAT> & phis) const;
private:

	int numRule_ = 0;

	int numElem_ = 0;

	elephon::Auxillary::alignedvector::aligned_vector<FAT> thetas_;

	elephon::Auxillary::alignedvector::aligned_vector<SAT> phis_;

	elephon::Auxillary::alignedvector::DV weights_;

	void get_function_data(
			Functor const & f,
			FAT const * theta,
			SAT const * phi,
			int numEvals,
			RT * data) const;

	void get_rule_data(int numRule);
};

} /* namespace Algorithms */
} /* namespace elephon */

#include "Algorithms/SphereIntegrator.hpp"
#endif /* ELEPHON_ALGORITHMS_SPHEREINTEGRATOR_H_ */
