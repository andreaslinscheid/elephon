/*	This file InputBase.hpp is part of elephon.
 *
 *  elephon is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  elephon is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with elephon.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Created on: Nov 15, 2014
 *      Author: Andreas Linscheid
 */

#include "IOMethods/InputBase.h"
#include <typeinfo>
#include <type_traits>
#include <string>
#include <stdexcept>
#include <sstream>
#include <fstream>

namespace elephon
{
namespace IOMethods
{

template<class derived>
InputBase<derived>::InputBase() { };

template<class derived>
InputBase<derived>::InputBase(InputFile const& inputFile)
{
	this->parse_variables(inputFile);
};

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,T const& defaultValue,T &value) const
{
	std::vector<T> oneElement;
	std::vector<T> onedefaultValueElement(1,defaultValue);
	this->get_option(valueString,onedefaultValueElement,oneElement);
	value = oneElement.front();
}

template<class derived>
template<typename T>
void InputBase<derived>::get_option(std::string const& valueString,T &value) const
{
	if ( valueString.empty() )
		throw std::runtime_error("No default value, but also noting to covert into a value.",1);
	//we don't care what the default is, since from this point valueString is either successfully parsed or
	//	the input fails.
	this->get_option(valueString,value,value);
}

template<class derived>
template<typename T>
void InputBase<derived>::get_option(
		std::string const& valueString,
		std::vector<T> const& defaultValue,
		std::vector<T> &values) const
{
	if ( valueString.empty() )
	{
		values = defaultValue;
	} else
	{
		std::stringstream ss(valueString);
		if ( std::is_same<typename std::remove_cv<T>::type ,bool>::value )
			ss >> std::boolalpha;
		T element;
		while ( not ( (ss.tellg() == -1) or (ss.tellg() == static_cast<int>(valueString.size()) )) )
		{
			ss >> element;
			std::string nameOfType = typeid(element).name();
			if ( ss.fail() )
				throw std::runtime_error( std::string("Failed to parse the value string ")
					+ valueString + " as " + nameOfType );

			values.push_back(element);
		};
	}
}

template<class derived>
template<typename T>
void InputBase<derived>::get_option(
		std::string const& valueString,
		std::vector<T> &values) const
{
	if ( valueString.empty() )
		throw std::runtime_error("No default value, but also nothing to covert into a value.",1);
	this->get_option(valueString,values,values);
}

template<class derived>
void InputBase<derived>::build_input_manual(std::string const& fileName) const
{
	std::string textUserManualString = "This manual was automatically generated by the elephon project.\n"
			"DO NOT EDIT THIS FILE ALL CHANGES WILL BE LOST!\n";
	textUserManualString += manual_;

	std::ofstream file( fileName.c_str() );
	file << textUserManualString;
}

template<class derived>
void InputBase<derived>::add_option_to_manual(std::string const& textWithOptionDescription)
{
	manual_ += textWithOptionDescription;
}

template<class derived>
void InputBase<derived>::parse_variables(InputFile const& inputFile)
{
	for ( size_t i = 0 ; i < mebrFctnPtrToVariableParsing_.size(); ++i) {
		 (static_cast<derived*>(this)->*mebrFctnPtrToVariableParsing_[i])(inputFile);
	}
	isInit_ = true;
}

template<class derived>
void InputBase<derived>::register_variable_parsing( void(derived::* function )(InputFile const&) )
{
	mebrFctnPtrToVariableParsing_.push_back(function);
}
} /* namespace IOMethods */
} /* namespace elephon */
